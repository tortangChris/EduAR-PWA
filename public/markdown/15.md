# Final Assessment: Algorithms and Data Structures

This final assessment will evaluate your understanding of core concepts in algorithms and data structures. It includes multiple-choice questions, short coding exercises, and conceptual explanation tasks based on the modules covered.

---

## General Instructions

![algo](../icons/image.png)

- Answer all questions.
- For coding questions, write clean and efficient code.
- You may use pen and paper for scratch work.
- No external resources allowed during the test.

---

## Coverage

This assessment includes the following topics:

- Introduction to Algorithms
- Searching Algorithms
- Sorting Algorithms
- Introduction to Data Structures
- Advanced Data Structures
- Graph Algorithms
- Dynamic Programming

---

## Part I: Multiple Choice (1 point each)

Choose the best answer for each question.

1. Which of the following is a characteristic of a greedy algorithm?

   - A. Explores all possible options before choosing
   - B. Solves subproblems independently and stores results
   - C. Makes locally optimal choices at each step
   - D. Uses recursion and memoization

2. The time complexity of Merge Sort is:

   - A. O(n)
   - B. O(n log n)
   - C. O(nÂ²)
   - D. O(log n)

3. Which data structure is best for implementing a queue?

   - A. Stack
   - B. Linked List
   - C. Array
   - D. Graph

4. In a Binary Search Tree (BST), what is the maximum number of children a node can have?

   - A. 1
   - B. 2
   - C. 3
   - D. Unlimited

5. What is the main advantage of dynamic programming over divide-and-conquer?
   - A. Simpler code
   - B. Faster execution for all problems
   - C. Avoids recomputation by storing results
   - D. Uses recursion more effectively

---

## Part II: Short Answer (3 points each)

Answer the following questions briefly.

1. Explain the difference between BFS and DFS in terms of their traversal strategy.
2. What is memoization and how does it improve algorithm performance?
3. Describe a real-world example where a hash table would be the most efficient data structure.
4. How does quicksort achieve its average-case performance of O(n log n)?
5. Why is Dijkstra's algorithm not suitable for graphs with negative edge weights?

---

## Part III: Coding Problems (10 points each)

Write your answers in Python or JavaScript.

### 1. Fibonacci with Memoization

Write a function that returns the nth Fibonacci number using memoization.

### 2. Binary Search

Implement binary search to find a target value in a sorted array.

### 3. Graph Representation

Create an adjacency list representation of a graph and write a function to add an edge.

---

## Rubric

| Criteria                     | Points |
| ---------------------------- | ------ |
| Multiple Choice              | 10     |
| Short Answer                 | 15     |
| Coding (Correctness)         | 20     |
| Coding (Code quality, logic) | 5      |
| **Total**                    | **50** |

---

## Submission

- Submit all your answers as a single `.zip` or `.pdf` file.
- Include your name, section, and date.
- Deadline: **[Insert date here]**

Good luck!

---
